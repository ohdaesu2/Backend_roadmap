웹 보안 지식
=========

### HTTPS(HTTP Secure)
- HTTP(Hyper Text Transfer Protocol)의 보안이 강화된 버전이다.
- 일반 HTTP의 문제는 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않아 도난의 위험성이 크다.
- HTTTPS는 SSL(Secure Socket Layer, 보안 소켓 계층)을 사용함으로써 이 문제를 해결했다.
- SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버 브라우저가 민감한 정보를 주고받을 때 도난당하는 것을 막아준다.

HTTPS의 보안 정책  
![스크린샷 2022-02-09 오후 8 12 10](https://user-images.githubusercontent.com/90598930/153213108-2e375ca4-5dd8-4506-8069-e1a9c697e6d0.png)
- SSL(Secure Socket Layer) 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 데이터를 암호로 바꾸는 작업을 한다.
- TLS(Transport Layer Security)은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고,
- 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 인증하는 기능도 제공한다.

보안 이외의 HTTPS의 장점
- SEO(Search Engine Optimization) 품질 향상
    - 검색엔진 최적화(SEO)가 매우 좋아진다.
- AMP(Accelerated Mobile Pages) 구축
    - 가속화된 모바일 페이지(AMP)를 만들고 싶을 때 HTTPS가 필요
    - AMP란 구글이 만든 것으로 모바일 기기에서 훨씬 빠르게 콘텐츠를 로딩하기 위한 방법이다.
- 모바일 친화적인 웹사이트를 만드는 것과 모바일 검색순위 및 지역에 SEO를 증가시키는 것이 중요해지는 요즘 HTTPS는 더욱 중요해진다!

HTTPS의 단점
- 암호화된 정보를 교환하기 때문에 서버가 과부하에 걸리는 경우가 발생한다
- 접속이 끊기게 되면 다시 처음부터 시작해야 한다.

***
### SSL/TLS
SSL(Secure Socket Layer)
![스크린샷 2022-02-09 오후 8 52 42](https://user-images.githubusercontent.com/90598930/153213189-d75e500d-a8d8-4d7d-94aa-44c741f0db5b.png)
- 브라우저 또는 사용자의 컴퓨터 서버 또는 웹사이트 간의 주고 받는 정보를 암호화
- SSL은  인증되지 않은 사용자의 방해로부터 각 세션 중에 교환된 중요한 데이터를 보호한다.
- SSL을 사용하게 되면 로그인, 회원가입, 예약 등의 개인정보를 입력하더라도 스니핑(Sniffing)에 의하여 정보를 도용당할 걱정이 없다.
- SSL의 목적은 스니핑의 방지(Sniffing Prevention)라고 할 수 있다.

TLS(Transport Layer Security)
- SSL의 최종 버전에서 소윤권이 바뀌면서 이름이 변경된 것.
- TLS의 첫 버전(1.0)은 SSL의 최종 버전(3.0)을 계승한다.

SSL의 암호화
- SSL은 보안과 성능상의 이유로 두가지 암호화 기법을 혼용해서 사용
- 대칭키(대칭 세션 키)
    - 암호를 만드는 행위인 암호화를 할 때 사용하는 일종의 비밀번호를 키(Key)라고 한다.
    - 키에 따라서 암호화된 결과가 달라지기 때문에 키를 모르면 암호를 푸는 행위인 복호화를 할 수 없다.
    - 대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법이다. 
- 공개키(비대칭키)
    - 대칭키의 단점은 대칭키가 유출되면 키를 획득한 공격자는 암호 내용을 복호화 할 수 있게 돼서, 암호화가 무용지물이 된다. 
    - 공개키 방식은 두가지 키를 이용하는데, 비공개키(private key)와 공개키(public key)
    - 비공개키는 자신만이 가지고 있고, 공개키만 타인에게 제공
    - 공개키는 정보를 암호화만 할 수 있고, 비공개키를 가지고 있어야 복호화가 가능하다!

SSL 인증서
- SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서 
- 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달
- 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증한 후 다음 절차를 수행한다.
![스크린샷 2022-02-16 오후 2 15 18](https://user-images.githubusercontent.com/90598930/154209538-85817426-36a6-4f4d-90ad-471aae498b72.png)

- SSL 인증서의 역할은 다음과 같다. 
    1) 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장
    2) SSL 통신에 사용할 공개키를 클라이언트에게 제공

CA(Certificate authority)
- 인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할
- 이 역할을 하는 민간기업들을 CA(Certificate authority)라고 부른다. 
- SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해서 인증서를 구입해야 한다! 

SSL의 동작 방법
- SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다. 
- 공개키는 이상적인 통신 방법이지만, 공개키 방식의 암호화는 매우 많은 컴퓨터 자원을 사용한다.
- 반면 암호화와 복호화에 사용되는 키가 동일한 대칭키 방식은 적은 컴퓨터 자원으로 암호화를 수행할 수 있기 때문에 효율적이지만,
- 수신측과 송신측이 동일한 키를 공유해야 하기 때문에 보안의 문제가 발생한다. 
- 따라서 SSL은 공개키와 대칭키의 장점을 혼합한 방식을 사용한다!
- 클라이언트와 서버가 주고받는 실제 정보는 대칭키 방식으로 암호화하고, 
- 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받는다.
- > 실제 데이터: 대칭키  
  > 대칭키의 키: 공개키
- 컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 ***악수 -> 전송 -> 세션 종료***  3가지 단계가 있다. 

![스크린샷 2022-02-16 오후 2 39 02](https://user-images.githubusercontent.com/90598930/154209553-64c14db0-2a35-4624-ab27-e035e0545e42.png)


악수 (Handshake)
- 실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake를 한다. 이 과정을 통해 상대방의 존재 유무를 확인한다.
- SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 Handshake를 진행하는데 이 때 SSL 인증서를 주고 받는다. 
- Handshake 단계에서 클라이언트와 서버가 통신하는 과정을 순서대로 살펴보면 다음과 같다. 
    1) 클라이언트가 서버에 접속한다. 이 단계를 Client Hello 라고 한다. 이 단계에서 주고받는 정보는 다음과 같다.  
    >**클라이언트 측에서 생성한 랜덤 데이터**   
     **클라이언트가 지원하는 암호화 방식들** : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 
     협상을 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.   
     **세션 아이디** : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이때 사용할 연결에 대한 식별자를 서버에 전송
    2) 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 됩니다. 이 단계에서 주고 받는 정보는 아래와 같습니다.
    > **서버 측에서 생성한 랜덤 데이터**  
    **서버가 선택한 클라이언트의 암호화 방식** : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달. 
    이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.   
    **인증서**
    3) 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다.  
    만약 CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다.  
    복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 이러한 절차로 인증서를 전송한 서버를 신뢰할 수 있게 된다.
       - 클라이언트는 2번 단계를 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret이라는 대칭키를 생성하게 돤다.  
       - 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. 
       - 이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출 되어서는 안된다.
       - pre master secret 값을 서버에 전달할 때, 사용하는 방법이 바로 공개키 방식이다. 
       - 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 
       - 그럼 서버의 공개키를 어떻게 구할 수 있을까요? 서버로부터 받은 인증서 안에 들어있다. 
       - 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.
    4) 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다.   
    이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 된다.  
    그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서  pre master secret 값을 master secret 값으로 만든다.   
    master secert 은 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화한 후에 주고 받게 된다. 
    이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 된다.
    5) 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다. 
    
세션
- 세션은 실제로 서버와 클라이언트가 데이터를 주고받는 단계이다.  
- 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 것이다.  
- 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.
- 이처럼 대칭키와 공개키를 조합해서 사용하는 이유는, 속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고,
- 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다! 

세션 종료
- 데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알리고, 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.

***
### 컨텐츠 보안 정책
CSP(Content Security Policy)
- 신뢰된 웹 페이지 context에서 악의적인 콘텐츠를 실행하게 하는 사이트 간 스크립팅(XSS), 클릭재킹(Click Jacking),
- 그리고 기타 코드인젝션 공격을 예방하기 도입된 컴퓨터 보안 표준

CSP를 사용하는 방법
- 웹 서버의 Response Header에 Content-Security-Policy 헤더를 추가하도록 설정하거나
- HTML에 <meta> 태그를 사용하여 추가할 수 있다.
  ![스크린샷 2022-02-09 오후 9 37 47](https://user-images.githubusercontent.com/90598930/153213247-f0203cec-a217-4eda-94d5-bb78769e31f6.png)

XSS(Cross Site Scripting, 크로스 사이트 스크립팅)
- 웹사이트 관리자가 아닌 사람이 웹 페이지에 악성 스크립트를 삽입할 수 있는 취약점
- 이 취약점은 웹 어플리케이션이 사용자로부터 입력 값을 제대로 validation 하지 않을 경우 발생한다.
- 이 취약점으로 해커가 사용자의 정보(쿠키, 세션)을 탈취하거나, 자동으로 비정상적인 기능을 수행하게 할 수 있다.

Click Jacking(클릭재킹)
- 웹 사용자가 자신이 클릭하고 있다고 인지하는 것과 다른 어떤 것을 클릭하게 속이는 악의적인 기법
- 잠재적으로 공격자는 비밀 정보를 유출시키거나 그들의 컴퓨터에 대한 제어를 획득할 수 있다.
***
### CORS
CORS(Cross-Origin Resource Sharing)
- 추가 HTTP Header를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여
  Origin(출처)
  ![](../../../../var/folders/2t/19jmqkvn5c9dpyjys7t98n9r0000gn/T/TemporaryItems/NSIRD_screencaptureui_ACdcYD/스크린샷 2022-02-09 오후 9.49.45.png)
- 위 그림에 있는 Protocal, Host 등등 + 포트 번호(:80, :43)까지 합친 것을 Origin 이라 한다.

SOP(Same-Origin Policy)
- 웹 생태계에는 다른 Origin로의 리소스 요청을 제한하는 것과 관련된 두 가지 정책이 존재한다. (CORS, SOP)
- "같은 Origin에서만 리소스를 공유할 수 있다" 라는 규칙을 가진 정책
- 그러나 웹이라는 오픈소스 환경에서 다른 Origin에 있는 리소스를 가져와서 사용하는 일이 굉장히 흔해졌다.
- 이를 모두 막을 수 없으니 몇 가지 예외 조항이 생겨났는데, 그 중 하나가 "CORS 정책을 지킨 리소스 요청" 이다.

같은 출처(Origin)와 다른 출처(Origin)의 구분
- URL 구성 중 Scheme, Host, Port 이 3가지만 동일하면 된다.
- https://evan-moon.github.io 와 같은 출처로 인정되는 예시는 다음과 같다.
  ![스크린샷 2022-02-09 오후 10 00 35](https://user-images.githubusercontent.com/90598930/153213334-f3eeca2d-066d-424e-9765-d2993ead550e.png)

***
### OWASP 보안 정책
OWASP(The Open Web Application Security Project)
- 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구한다.
- OWASP TOP 10은 웹 어플리케이션 취약점 중에서도 빈도가 많이 발생하고, 보안상 영향을 크게 줄 수 있는 10가지를 선정한 것이다.
- 2004년, 2007년, 2010년, 2013년, 2017년을 기준으로 발표되었고, 문서가 공개되었다.

OWASP TOP 10
![스크린샷 2022-02-09 오후 10 23 55](https://user-images.githubusercontent.com/90598930/153213360-fc442372-08a3-4a80-864b-cd12acd5547d.png)
1) Injection(인젝션)
    - 인젝션 취약점은 신뢰할 수 없는 데이터가 명령어나 쿼리문의 일부분이 인터프리터로 보내질 때 발생
    - 공격자의 악의적인 데이터는 예상하지 못하는 명령을 실행하거나 적절한 권한 없이 데이터에 접근하도록 인터프리터를 속일 수 있다.
   > 인터프리터: 코드를 한 줄씩 읽어 내려가며 실행하는 프로그램 ex) ㅖpython
2) Broken Authentication and Session Management(인증 및 세션 관리 취약점)
    - 인증, 세션 관리와 관련된 애플리케이션 기능이 정확하게 구현되어 있지 않아서, 공격자가 패스워크, 키 또는 세션 토큰을 해킹, 탈취하는 것
3) Cross-Site Scripting (XSS) (크로스 사이트 스크립팅)
    - 애플리케이션이 신뢰할 수 없는 데이터를 가져와 적절한 검증이나 제한 없이 웹브라우저로 보낼 때 발생
    - XSS는 공격자가 피해자의 브라우저에 스크립트를 실행하여 사용자 세션 탈취, 웹사이트 변조, 악의적인 사이트로 이동할 수 있다.
4) Broken Access Control(취약한 접근 제어)
    - 인증된 사용자가 수행할 수 있는 것에 대한 제한이 제대로 적용되지 않는 것을 의미
    - 공격자는 이러한 취약점을 악용하여 사용자의 계정 엑세스, 중요한 파일보기, 사용자의 데이터 수정, 엑서스 권한 변경 등을 시도할 수 있다.
5) Security Misconfiguration (보안 설정 오류)
    - 기본으로 제공되는 값은 종종 안전하지 않기 때문에 보안 설정은 정의, 구현 및 유지되어야 한다.
    - 또한 소프트웨어는 최신의 상태로 유지해야 한다.
6) Sensitive Data Exposure (민감 데이터 노출)
    - 공격자는 신용카드 사기, 신분 도용 또는 다른 범죄를 수행하는 등 약하게 보호된 데이터를 훔치거나 변경할 수 있다.
    - 중요 데이터가 저장 또는 전송 중이거나 브라우저와 교환하는 경우 특별히 주의하여야 하며, 암호화와 같은 보호조치를 취해야 한다.
7) Insufficient Attack Protection (공격 방어 취약점)
    - 대부분의 애플리케이션과 API는 수동 및 자동화된 공격을 모두 탐지(detect), 방지(prevent), 대응(respond)할 수 있는 기본 기능이 부족하다.
    - 공격 방어(protection)는 기본적인 입력 유효성 검사를 뛰어 넘어 자동으로 탐지, 로깅, 응답 및 공격 시도 차단을 포함한다.
    - 애플리케이션 소유자는 공격으로부터 보호하기 위해 패치를 신속하게 배포할 수 있어야 한
8) Cross-Site Request Forgery (CSRF) (크로스 사이트 요청 변조)
    - 로그인 뒤 피해자의 취약한 웹 애플리케이션에 피해자의 세션 쿠키와 기타 다른 인증정보를 자동으로 포함하여 위조된 HTTP 요청을 강제로 보내도록 하는 것
    - 공격자가 취약한 애플리케이션이 피해자로부터의 정당한 요청이라고 오해할 수 있는 요청들을 강제로 만들 수 있다.
9) Using Components with Known Vulnerabilities (알려진 취약점이 있는 컴포넌트 사용)
    - 컴포넌트, 라이브러리, 프레임워크 및 다른 소프트웨어 모듈은 대부분 항상 전체 권한으로 실행된다.
    - 이러한 취약한 컴포넌트를 악용하여 공격하는 경우 심각한 데이터 손실이 발생하거나 서버가 장악될 수 있다.
   > 컴포넌트: 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈을 뜻한다.
10) Underprotected APIs (취약한 API)
    - 최신 애플리케이션 및 API에는 API(SOAP / XML, REST / JSON, RPC, GWT 등)에 연결하는 브라우저 및
    - 모바일 애플리케이션의 자바스크립트와 같은 여러 클라이언트 애플리케이션이 포함되는 경우가 많다.
    - 이러한 API는 대부분 보호되지 않으며 수많은 취약점을 가질 수 있다. 


