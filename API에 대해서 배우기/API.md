# API란?

![image](https://user-images.githubusercontent.com/97514510/149771711-9d46d828-57e5-40b5-b909-239805464528.png)

API란 레스토랑에서 점원의 역할과 같이, 손님(프로그램)이 주문할 수 있도록 메뉴(명령 목록)을 정리하고, 주문(명령)을 받으면 요리사(다른 응용 프로그램)에 해당 요청사항을 전달한 뒤 요쳥한 메뉴(명령에 대한 결과)를 전달한다.


쉽게 말해, API는 프로그램들이 서로 상호작용할 수 있도록 도와주는 매개체이다.

## API의 역할
#### 1. API는 서버, 데이터베이스에 대한 출입구 역할.
  - 데이터베이스에는 프로그램과 관련된 중요한 정보들이 저장됨, 아무나 접근할 수 있으면 안됨.
  - API는 이를 방지하기 위해 서버와 데이터베이스의 출입구 역할을 하며, 허용된 사람들에게만 접근성을 부여.

#### 2. API는 애플리케이션과 기기가 원활하게 통신할 수 있도록 한다.
  - API는 애플리케이션과 기기가 데이터를 원활히 주고받을 수 있도록 도움.

#### 3. API는 모든 접속을 표준화한다.
  - API는 모든 접속을 표준화하기 때문에 기계/운영체제 등과 상관없이 누구나 동일하게 액세스 가능.
  - 쉽게 말해, API는 프로그램끼리 서로 자동으로 인식하고 연결될 수 있도록 함.


## API의 유형
#### 1) Private API
  - 내부 API. 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행. 제 3자에게 프로토콜이나 사용법 등이 노출되지 않음.
#### 2) Public API
  - 개방형 API. 모두에게 공개되고 누구나 제한없이 사용 가능.
#### 3) Partner API
  - 파트너 API. 데이터 공유에 동의하는 특정인들만 사용 가능. 주로 비즈니스 관계에서 파트너 간 소프트웨어를 통합하기 위해 사용됨.

### 사용하는 이유?
Private API를 이용할 경우, 개발자간에 애플리케이션 코드를 작성하는 방법을 표준화함으로써, 간소화되고 빠른 프로세스 처리가 가능.

또한, 소프트 웨어를 통합하고자 할 때 개발자들 간의 협업을 용이하게 만들 수 있음.


Public API or partner API 를 사용하면, 기업은 타사 데이터를 활용하여 브랜드 인지도를 높이거나 고객 데이터베이스를 확장하여 전환율을 높일 수 있음.

전환율이란 웹사이트를 방문한 사람 중, 소정의 유도된 행위를 한 방문자의 비율을 말한다. 유도된 행위란, 예를 들면, 무언가를 구매한다든가 사이트의 핵심 문서를 읽는다든가, 무언가를 다운로드받는다든가 하는 행위를 말한다.




# 인증
인증은 프론트엔드 관점에서 봤을 때 사용자의 로그인, 회원가입과 같이 사용자의 도입부분을 가리키고, 백엔드 관점에서 봤을 때는 모든 API 요청에 대해 사용자를 확인하는 작업.
서버에서는 사용자 A,B가 각각 요청을 보냈을 때 누구의 요청인지를 정확히 알아야 함. 
만일 그렇지 못한다면, 각 고객의 정보가 타인에게 유출되는 최악의 상황이 발생할 수 있음.
그렇기에 앱(프론트 엔드)에서는 이용자가 누구인지를 알만한 단서를 서버에 보내야 하며, 서버(백엔드)는 그 단서를 파악해 각 요청에 맞는 데이터를 돌려준다.


이 때 앱에서 서버로 요청을 보내는 가장 일반적이고 자주 쓰이는 통신 방식이 바로 HTTP.

HTTP 통신은 응답 후 연결을 끊고 과거에 대한 정보를 전혀 담지 않음. 
즉, 지금 보낼 HTTP 요청은 동일한 사용자가 보내더라도, 지난 번에 자신의 정보를 담아 보냈던 HTTP 요청과 전혀 관계가 없음. 
따라서 각각의 HTTP 요청에는 주체가 누구인지에 대한 정보가 필수적임.

가장 빠르고 간편한 인증방식으로 요청이 발생했을 때 HTTP 문서에 사용자의 비밀번호를 넣어서 보낸 뒤 확인하는 방법이 있으나, 최악의 보안을 갖는 인증 방식이다.
보통 HTTP 문서는 전송될 때 특별한 암호화 과정을 거치지 않기 때문에 외부 사용자나 해커에 의한 intercept에 매우매우 취약.
따라서 다음과 같은 다양한 인증 방식을 사용한다.

## Session/Cookie
![image](https://user-images.githubusercontent.com/97514510/149774638-755d0f2f-ac32-4369-8d81-a3ba22907849.png)

  1) 사용자가 로그인을 함.
  2) 서버에서는 계정정보를 읽어 사용자를 확인함.
  3) 서버는 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장하고 이와 연결되는 세션ID를 발행함.
  4) 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장한 뒤, 인증이 필요한 요청마다 쿠키를 헤더(HTTP 문서에서 전송된 요청에 대한 설명이 있는 부분)에 실어 보냄.
  5) 서버에서는 매 요청마다 쿠키를 받아 세션 저장소에서 대조한 뒤, 대응되는 정보를 가져옴.
  6) 즉 로그인이 완료되고 나면, 사용자가 데이터를 요청할 때 마다 매번 ID, PW를 확인하는게 아니라 처음에 부여한 사용자에 대한 ID값과 그와 대응돠는 세션ID를 비교.
  7) 중요한 정보는 첫 로그인때만 전송되고 나머지 활동에서는 세션ID를 활용하여 인증.
  8) 네이버 로그인 뒤, 내 블로그 보기나 내 가입 카페 보기 등등으로 이동할 때 비밀번호를 저장해뒀다가 매번 그걸로 확인하는게 아니라 부여받은 세션ID를 이용해서 누군지 찾고 내 블로그를 알맞게 가져와서 보여주는 듯.
  9) 인증이 완료되고 나면 서버는 사용자에게 맞는 데이터를 보내줌.
 
세션 쿠키 방식의 인증은 기본적으로 세션 저장소를 필요로 함(주로 Redis). 세션 저장소는 로그인을 했을 때 사용자의 정보를 저장하고 열쇠가 되는 세션ID값을 만듦. 그리고 HTTP 헤더에 실어 사용자에게 돌려보내줌. 그러면 사용자는 해당 Session ID를 쿠키로 보관하고 있다 인증이 필요한 요청에 쿠키(세션ID)를 넣어 다시 서버에 보냄. 웹 서버에서는 세션 저장소에서 쿠키(세션ID)를 받고 저장되어 있는 정보와 매칭시켜 인증을 완료함.

## Session과 Cookie의 차이?
Session이란 서버가 가지고 있는 정보이고, Cookie란 세션의 정보를 얻기 위한 key로 각 사용자에게 발급된다.

이를테면 헬스장 라커룸이 회원마다 하나씩 배정되어있고, 라커 안에 있는 각 회원의 소지품이 개인정보(session), 회원마다 발급되는 회원증을 Cookie라고 생각하면 될 것 같다.
그리고 헬스장에서 카운터를 봐주는 직원이 세션 저장소라고 생각하고, 각 회원에게 배정된 라커가 몇 번인지는 직원만이 알고있다.

회원이 헬스장을 처음 등록할때만 개인정보를 제시하고, 이를 바탕으로 직원이 회원증을 발급해주면, 

이후에는 회원이 필요한 물건이 있을때마다 카운터에 와서 회원증만 카운터에 보이면, 직원이 저장된 정보를 바탕으로 회원에게 배정된 올바른 라커 번호를 확인하고 거기서 주인에게 맞는 물건을 꺼내주는 식.

그냥 HTTP 파일 헤더에 바로 비밀번호를 넣어서 요청하는 방식, 혹은 Session 없이 Cookie만 사용해서 인증하는 방식은 회원이 라커 번호가 대문짝만하게 써져 있는 카드키를 직접 가지고 있는 상황에 비유할 수 있을듯. 이 경우 카드키를 뺏기면 바로 라커 안의 내용물을 탈취당한다ㅠㅠ

힘 없는 일개 회원이 라커 카드키를 관리하는 것보다, 힘 있고 관리자의 위치에 있는 직원이 자기만 볼 수 있는 데이터베이스를 통해서 관리해 주는것이 훨씬 안전함.

결과적으로 Session을 추가하여 인증의 책임을 서버가 지게하기 위해 세션을 사용하는 셈(사용자가 해킹당하는 것보단 서버가 해킹당하는게 훨씬 어려우므로).


### Session/Cookie 방식의 장점
  1. 이 방식은 쿠키를 매개로 인증을 거침. 여기서 쿠키는 사용자의 직접적인 중요 정보가 아닌, 세션 저장소에 저장된 정보를 얻기 위한 "열쇠"일 뿐. 
따라서 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고있지 않음(중요 정보는 서버 세션에). 단순히 회원증만 뺏어서는, 라커 번호를 알 수 없는 셈. 이는 위의 계정정보를 직접 담아 인증을 거치는 것보단 안전.
2. 사용자 A는 1번, 사용자 B는 2번 이런식으로 사용자마다 고유의 ID값을 발급받게 됨. 그렇게 되면 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이. 

### Session/Cookie 방식의 단점
1. 만일 B 사용자가 A 사용자의 Cookie를 탈취한 뒤, A 사용자인척 서버에 HTTP 요청을 보내면 서버는 B 사용자를 A 사용자로 착각하고 정보를 잘못 뿌리게 됨. 이를 세션 하이재킹 공격이라고 한다.
1-1. 이에 대한 해결책으로, HTTP 문서 내의 쿠키를 읽기 어렵게 만들거나, Session에 유효 시간을 넣는 방법이 있음.
2. 서버에서 세션 저장소를 필요로 하기 때문에 저장소용량이 늘어나게 됨. 부하가 늘어남.

## OAuth
![image](https://user-images.githubusercontent.com/97514510/149778473-1472ea8a-e69b-428e-b6fa-8cd90bb03afe.png)

웹 서핑을 하다 보면 외부 소셜 계정을 기반으로 간편히 회원가입 및 로그인할 수 있는 웹 어플리케이션을 쉽게 찾아볼 수 있음.
본인인증 및 로그인 뿐만 아니라, 연동되는 외부 앱에서 정보까지 다 가져와서 동기화할 수 있음.
특정 달력 어플에 구글 계정으로 로그인한 뒤 구글 캘린더의 정보를 가져와서 업데이트하는 경우.

이 때 사용되는 프로토콜이 바로 OAuth이다.
> OAuth란 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다.

위에서 외부 애플리케이션은 사용자 인증을 위해 Facebook과 Apple 및 Google의 등의 사용자 인증 방식을 사용함.
이 때, OAuth를 바탕으로 제 3자 서비스(위의 어플)는 외부 서비스(Facebook, Apple, Google)의 특정 자원을 접근 및 사용할 수 있는 권한을 인가받게 됨.

