# API란?

![image](https://user-images.githubusercontent.com/97514510/149771711-9d46d828-57e5-40b5-b909-239805464528.png)

API란 레스토랑에서 점원의 역할과 같이, 손님(프로그램)이 주문할 수 있도록 메뉴(명령 목록)을 정리하고, 주문(명령)을 받으면 요리사(다른 응용 프로그램)에 해당 요청사항을 전달한 뒤 요쳥한 메뉴(명령에 대한 결과)를 전달한다.


쉽게 말해, API는 프로그램들이 서로 상호작용할 수 있도록 도와주는 매개체이다.

## API의 역할
#### 1. API는 서버, 데이터베이스에 대한 출입구 역할.
  - 데이터베이스에는 프로그램과 관련된 중요한 정보들이 저장됨, 아무나 접근할 수 있으면 안됨.
  - API는 이를 방지하기 위해 서버와 데이터베이스의 출입구 역할을 하며, 허용된 사람들에게만 접근성을 부여.

#### 2. API는 애플리케이션과 기기가 원활하게 통신할 수 있도록 한다.
  - API는 애플리케이션과 기기가 데이터를 원활히 주고받을 수 있도록 도움.

#### 3. API는 모든 접속을 표준화한다.
  - API는 모든 접속을 표준화하기 때문에 기계/운영체제 등과 상관없이 누구나 동일하게 액세스 가능.
  - 쉽게 말해, API는 프로그램끼리 서로 자동으로 인식하고 연결될 수 있도록 함.


## API의 유형
#### 1) Private API
  - 내부 API. 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행. 제 3자에게 프로토콜이나 사용법 등이 노출되지 않음.
#### 2) Public API
  - 개방형 API. 모두에게 공개되고 누구나 제한없이 사용 가능.
#### 3) Partner API
  - 파트너 API. 데이터 공유에 동의하는 특정인들만 사용 가능. 주로 비즈니스 관계에서 파트너 간 소프트웨어를 통합하기 위해 사용됨.

### 사용하는 이유?
Private API를 이용할 경우, 개발자간에 애플리케이션 코드를 작성하는 방법을 표준화함으로써, 간소화되고 빠른 프로세스 처리가 가능.

또한, 소프트 웨어를 통합하고자 할 때 개발자들 간의 협업을 용이하게 만들 수 있음.


Public API or partner API 를 사용하면, 기업은 타사 데이터를 활용하여 브랜드 인지도를 높이거나 고객 데이터베이스를 확장하여 전환율을 높일 수 있음.

전환율이란 웹사이트를 방문한 사람 중, 소정의 유도된 행위를 한 방문자의 비율을 말한다. 유도된 행위란, 예를 들면, 무언가를 구매한다든가 사이트의 핵심 문서를 읽는다든가, 무언가를 다운로드받는다든가 하는 행위를 말한다.




# 인증
인증은 프론트엔드 관점에서 봤을 때 사용자의 로그인, 회원가입과 같이 사용자의 도입부분을 가리키고, 백엔드 관점에서 봤을 때는 모든 API 요청에 대해 사용자를 확인하는 작업.
서버에서는 사용자 A,B가 각각 요청을 보냈을 때 누구의 요청인지를 정확히 알아야 함. 
만일 그렇지 못한다면, 각 고객의 정보가 타인에게 유출되는 최악의 상황이 발생할 수 있음.
그렇기에 앱(프론트 엔드)에서는 이용자가 누구인지를 알만한 단서를 서버에 보내야 하며, 서버(백엔드)는 그 단서를 파악해 각 요청에 맞는 데이터를 돌려준다.


이 때 앱에서 서버로 요청을 보내는 가장 일반적이고 자주 쓰이는 통신 방식이 바로 HTTP.

HTTP 통신은 응답 후 연결을 끊고 과거에 대한 정보를 전혀 담지 않음. 
즉, 지금 보낼 HTTP 요청은 동일한 사용자가 보내더라도, 지난 번에 자신의 정보를 담아 보냈던 HTTP 요청과 전혀 관계가 없음. 
따라서 각각의 HTTP 요청에는 주체가 누구인지에 대한 정보가 필수적임.

가장 빠르고 간편한 인증방식으로 요청이 발생했을 때 HTTP 문서에 사용자의 비밀번호를 넣어서 보낸 뒤 확인하는 방법이 있으나, 최악의 보안을 갖는 인증 방식이다.
보통 HTTP 문서는 전송될 때 특별한 암호화 과정을 거치지 않기 때문에 외부 사용자나 해커에 의한 intercept에 매우매우 취약.
따라서 다음과 같은 다양한 인증 방식을 사용한다.

## Session/Cookie
![image](https://user-images.githubusercontent.com/97514510/149774638-755d0f2f-ac32-4369-8d81-a3ba22907849.png)

  1) 사용자가 로그인을 함.
  2) 서버에서는 계정정보를 읽어 사용자를 확인함.
  3) 서버는 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장하고 이와 연결되는 세션ID를 발행함.
  4) 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장한 뒤, 인증이 필요한 요청마다 쿠키를 헤더(HTTP 문서에서 전송된 요청에 대한 설명이 있는 부분)에 실어 보냄.
  5) 서버에서는 매 요청마다 쿠키를 받아 세션 저장소에서 대조한 뒤, 대응되는 정보를 가져옴.
  6) 즉 로그인이 완료되고 나면, 사용자가 데이터를 요청할 때 마다 매번 ID, PW를 확인하는게 아니라 처음에 부여한 사용자에 대한 ID값과 그와 대응돠는 세션ID를 비교.
  7) 중요한 정보는 첫 로그인때만 전송되고 나머지 활동에서는 세션ID를 활용하여 인증.
  8) 네이버 로그인 뒤, 내 블로그 보기나 내 가입 카페 보기 등등으로 이동할 때 비밀번호를 저장해뒀다가 매번 그걸로 확인하는게 아니라 부여받은 세션ID를 이용해서 누군지 찾고 내 블로그를 알맞게 가져와서 보여주는 듯.
  9) 인증이 완료되고 나면 서버는 사용자에게 맞는 데이터를 보내줌.
 
세션 쿠키 방식의 인증은 기본적으로 세션 저장소를 필요로 함(주로 Redis). 세션 저장소는 로그인을 했을 때 사용자의 정보를 저장하고 열쇠가 되는 세션ID값을 만듦. 그리고 HTTP 헤더에 실어 사용자에게 돌려보내줌. 그러면 사용자는 해당 Session ID를 쿠키로 보관하고 있다 인증이 필요한 요청에 쿠키(세션ID)를 넣어 다시 서버에 보냄. 웹 서버에서는 세션 저장소에서 쿠키(세션ID)를 받고 저장되어 있는 정보와 매칭시켜 인증을 완료함.

## Session과 Cookie의 차이?
Session이란 서버가 가지고 있는 정보이고, Cookie란 세션의 정보를 얻기 위한 key로 각 사용자에게 발급된다.

이를테면 헬스장 라커룸이 회원마다 하나씩 배정되어있고, 라커 안에 있는 각 회원의 소지품이 개인정보(session), 회원마다 발급되는 회원증을 Cookie라고 생각하면 될 것 같다.
그리고 헬스장에서 카운터를 봐주는 직원이 세션 저장소라고 생각하고, 각 회원에게 배정된 라커가 몇 번인지는 직원만이 알고있다.

회원이 헬스장을 처음 등록할때만 개인정보를 제시하고, 이를 바탕으로 직원이 회원증을 발급해주면, 

이후에는 회원이 필요한 물건이 있을때마다 카운터에 와서 회원증만 카운터에 보이면, 직원이 저장된 정보를 바탕으로 회원에게 배정된 올바른 라커 번호를 확인하고 거기서 주인에게 맞는 물건을 꺼내주는 식.

그냥 HTTP 파일 헤더에 바로 비밀번호를 넣어서 요청하는 방식, 혹은 Session 없이 Cookie만 사용해서 인증하는 방식은 회원이 라커 번호가 대문짝만하게 써져 있는 카드키를 직접 가지고 있는 상황에 비유할 수 있을듯. 이 경우 카드키를 뺏기면 바로 라커 안의 내용물을 탈취당한다ㅠㅠ

힘 없는 일개 회원이 라커 카드키를 관리하는 것보다, 힘 있고 관리자의 위치에 있는 직원이 자기만 볼 수 있는 데이터베이스를 통해서 관리해 주는것이 훨씬 안전함.

결과적으로 Session을 추가하여 인증의 책임을 서버가 지게하기 위해 세션을 사용하는 셈(사용자가 해킹당하는 것보단 서버가 해킹당하는게 훨씬 어려우므로).


### Session/Cookie 방식의 장점
  1. 이 방식은 쿠키를 매개로 인증을 거침. 여기서 쿠키는 사용자의 직접적인 중요 정보가 아닌, 세션 저장소에 저장된 정보를 얻기 위한 "열쇠"일 뿐. 
따라서 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고있지 않음(중요 정보는 서버 세션에). 단순히 회원증만 뺏어서는, 라커 번호를 알 수 없는 셈. 이는 위의 계정정보를 직접 담아 인증을 거치는 것보단 안전.
2. 사용자 A는 1번, 사용자 B는 2번 이런식으로 사용자마다 고유의 ID값을 발급받게 됨. 그렇게 되면 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이. 

### Session/Cookie 방식의 단점
1. 만일 B 사용자가 A 사용자의 Cookie를 탈취한 뒤, A 사용자인척 서버에 HTTP 요청을 보내면 서버는 B 사용자를 A 사용자로 착각하고 정보를 잘못 뿌리게 됨. 이를 세션 하이재킹 공격이라고 한다.
1-1. 이에 대한 해결책으로, HTTP 문서 내의 쿠키를 읽기 어렵게 만들거나, Session에 유효 시간을 넣는 방법이 있음.
2. 서버에서 세션 저장소를 필요로 하기 때문에 저장소용량이 늘어나게 됨. 부하가 늘어남.

## 토큰 기반(JWT)
JWT는 세션/쿠키와 함께 모바일과 웹의 인증을 책임지는 대표주자. JWT는 Json Web Token의 약자로 인증에 필요한 정보들을 암호화시킨 토큰을 뜻함.
위의 세션/쿠키 방식과 유사하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보내게 됨.
![image](https://user-images.githubusercontent.com/97514510/149780248-41dfac38-4e56-47ee-a58b-59c394c17f8e.png)

jwt.io 사이트에서 암호화된 토큰을 볼 수 있음. 오른쪽의 정보가 왼쪽처럼 암호화됨.

토큰을 만들기 위해 크게 다음과 같은 세가지가 필요함.
#### 1) Header : 위 3가지 정보를 암호화할 방식(alg), 타입(type) 등이 포함.
#### 2) Payload : 서버에서 보낼 데이터가 포함. 일반적으로 유저의 고유 ID값, 유효기간이 들어감.
#### 3) Verify Signature :  Base64 방식으로 인코딩한 Header,payload 그리고 SECRET KEY를 더한 후 서명됨.
#### 최종적인 결과: Encoded Header + "." + Encoded Payload + "." + Verify Signature

Header와 Payload는 16진수로 변환되기만 할 뿐 따로 암호화되지 않아서 누구나 decoding할 수 있음. 요기에 user의 중요 정보가 포함되면 쉽게 노출될 수 있다.

Verify Signiture는 Secret Key를 알지 못하면 Encoding할 수 없음.

A 사용자가 만약 자신의 Access Token(JWT, 위의 사진에 있는 파일)을 조작하여 B 사용자의 정보를 보고싶다고 하자.
자신의 Access Token에서 ID 부분을 B 사용자의 ID로 바꿔치기 한 뒤 서버에 요청을 보냈다.
그러면 Header와 Payload는 그대로 encoding되지만, Verify Signature는 User의 Payload를 기반으로 암호화되었기 때문에 Payload의 정보가 일부 변하면 Encoding할 수 없다.

Payload의 ID를 바꿔치기했기 때문에 해당 부분에서는 나는 B 사용자입니다 라고 주장하지만, 원래는 A 사용자에게 발급되었던 토큰이기 때문에 Verify Signature 부분이 A사용자 정보 기반으로 Decoding된 상태라서 유효하지 않은 토큰으로 분류돼 인증이 실패함.

### 인증 방식
![image](https://user-images.githubusercontent.com/97514510/149781387-f371f29d-ecf8-4d4f-85db-b67a8725386d.png)

1. 사용자가 로그인을 한다.
2. 서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣음.
3. JWT 토큰의 유효기간을 설정.
4. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급.
5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어보냄.
6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 Encoding한 후, 조작 여부, 유효기간을 확인.
7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옴.  
 
세션/쿠키 방식과 가장 큰 차이점은 세션/쿠키는 세션 저장소에 유저의 정보를 넣는 반면, JWT는 토큰 안에 유저의 정보들이 넣는다는 점. 
물론 클라이언트(이용자) 입장에서는 HTTP 헤더에 세션ID나 토큰을 실어서 보내준다는 점에서는 동일하나, 서버 측에서는 인증을 위해 암호화(JWT)를 하냐, 별도의 저장소(Session)를 이용하냐는 차이가 발생함.

### JWT 방식의 장점
1. 간편함. 세션/쿠키는 별도의 저장소의 관리가 필요하지만 JWT는 발급한 후 매번 검증만 하면 되기 때문에 추가 저장소가 필요 없음. 이는 Stateless 한 서버를 만드는 입장에서는 매우 큰 강점. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미하는데, 이는 서버를 확장하거나 유지,보수하는데 유리.
2. 확장성이 뛰어남. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증함. 이에 선택적으로 이름이나 이메일 등을 받을 수 있는 권한도 받을 수 있습니다. (예를 들면, 회원가입 없이 Facebook 아이디로 로그인 등의 방식. 나중에 나옴ㅎㅎ)

### JWT 방식의 단점
1. 이미 발급된 JWT에 대해서는 돌이킬 수 없음. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용되는 것을 확인하면, 해당하는 사용자에게 할당된 세션을 지워버리면 됨. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능함(정보가 서버에 있는 것이 아니기 때문에, 요청이 오면 인증해 줄 수 밖에...). 따라서 악의적인 사용자는 유효기간이 지나기 전까지 신나게 정보들을 털어갈 수 있음. 
1-1. 해결책으로, 기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있음. 이따가 OAuth할 때 이어서 ㅎㅎ
 
2. Payload 정보가 제한적. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있음. (세션/쿠키 방식에서는 유저의 정보가 전부 서버의 저장소에 안전하게 보관됩니다) 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없음.
 
3. JWT의 길이. 세션/쿠키 방식에 비해 JWT의 길이는 길기 때문에 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생.

## Refresh Token
유효기간이 짧은 Token의 경우 그만큼 사용자는 로그인을 자주 해서 새롭게 Token을 발급받아야 하므로 불편함. 그러나 유효기간을 늘리자면, 토큰을 탈취당했을 때 보안에 더 취약해지게 됨.

Refresh Token은 Access Token과 똑같은 형태의 JWT.
처음에 로그인을 완료했을 때 Access Token과 동시에 발급되는 Refresh Token은 긴 유효기간을 가지면서, Access Token이 만료됐을 때 새로 발급해주는 열쇠(여기서 만료라는 개념은 그냥 유효기간을 지났다~).

** Access Token은 탈취당하면 정보가 유출되는건 동일하나 짧은 유효기간 안에만 사용이 가능하기에 더 안전하다는 의미. 

** Refresh Token의 유효기간이 만료됐다면, 사용자는 새로 로그인해야 함. Refresh Token도 탈취될 가능성이 있기 때문에 적절한 유효기간 설정이 필요(보통 2주, Access는 보통 1시간).

### Access Token + Refresh Token 인증 과정
![image](https://user-images.githubusercontent.com/97514510/149782652-42a4b62e-b5cb-4893-af8e-fbf79df950ca.png)

1. 사용자가 ID, PW를 통해서 로그인
2. 서버에서는 사용자가 입력한 정보를 바탕으로, 회원 DB를 탐색. 
3. DB에 존재하는 사용자임이 확인될 경우 Access Token과 Refresh Token을 발급해줌. 이 때 Refresh Token의 정보를 회원DB에 저장해둔다.
4. 사용자는 서버로부터 Access Token과 Refresh Token을 받고, 로그인에 성공함.
5. Refresh Token은 사용자 역시 안전한 곳에 보관해두고, 이후 데이터를 요청할 때 마다 Access Token을 HTTP의 헤더파일에 실어서 서버에 전송.
6. 서버는 사용자의 Access Token의 유효성을 검증한 후 이에 맞는 데이터를 보내줌.
7. 만약 시간이 지나서 Access Token이 만료된 경우, 사용자가 만료된 Token을 헤더에 실어서 서버에 보내면 서버는 Token이 만료됨을 확인하고 권한없음을 신호로 보냄.
8. 권한없음 신호를 받은 사용자는, 처음 로그인했을 때 안전한 곳에 보관해 두었던 Refresh Token을 만료된 Access Token과 함께 다시 서버로 보냄.
9. 서버는 두 Token을 받아서, Access Token이 조작되지 않았는지 먼저 확인하고, 사용자가 보낸 Refresh Token과 회원DB에 저장된 Refresh Token을 비교함. 두 Refresh Token이 동일하고, 유효기간 이내라면 해당 사용자에게 새로운 Access Token을 발급해줌.
10. 서버는 새로운 Access Token을 헤더에 실어 요청을 진행함.


### Access Token + Refresh Token의 장점
- 기존의 Access Token 방식만을 사용할 때보다 안전함.
- 보안이 중요한 프로젝트에서는 Refresh Token을 함께 사용하기를 권장

### Access Token + Refresh Token의 단점
- 구현이 복잡함. 검증 프로세스가 길어짐. (프론트, 백엔드 모두 복잡해짐)
- Access Token이 만료될 때마다 새롭게 발급하는 과정에서 HTTP 요청 횟수가 늘어남. 자원낭비로 귀결


## OAuth
![image](https://user-images.githubusercontent.com/97514510/149778473-1472ea8a-e69b-428e-b6fa-8cd90bb03afe.png)

웹 서핑을 하다 보면 외부 소셜 계정을 기반으로 간편히 회원가입 및 로그인할 수 있는 웹 어플리케이션을 쉽게 찾아볼 수 있음.
본인인증 및 로그인 뿐만 아니라, 연동되는 외부 앱에서 정보까지 다 가져와서 동기화할 수 있음.
특정 달력 어플에 구글 계정으로 로그인한 뒤 구글 캘린더의 정보를 가져와서 업데이트하는 경우.

이 때 사용되는 프로토콜이 바로 OAuth이다.
> OAuth란 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다.

위에서 외부 애플리케이션은 사용자 인증을 위해 Facebook과 Apple 및 Google의 등의 사용자 인증 방식을 사용함.
이 때, OAuth를 바탕으로 제 3자 서비스(위의 어플)는 외부 서비스(Facebook, Apple, Google)의 특정 자원을 접근 및 사용할 수 있는 권한을 인가받게 됨.

### OAuth 인증 방식
#### Authorization Code Grant
![image](https://user-images.githubusercontent.com/97514510/149779558-6165612d-4f69-4c38-ba4e-107c64dbf843.png)

1) Resource Owner : User, 즉 일반 사용자

2) Client : 내가 이용할 어플리케이션 서버(User와 혼동하지 않기!) 

3) Authorization Server : 권한을 관리하는 서버. 

4) Resource Server : OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버. 주의할 점은 내가 이용할 서버의 자원을 관리하는 곳이 아니라 OAuth를 관리하는 외부 서버의 자체 API임.

![image](https://user-images.githubusercontent.com/97514510/149779935-5a58c2a4-4a7b-4491-be3a-6bb5767e8976.png)

1. Resource Owner(사용자, User)가 Client(애플리케이션 서버)에 인증 요청을 함.
2. Client는 Authorization Request를 통해 Resource Owner에게 인증 수단(Facebook이나 Google Login URL)을 보냄.
3. Resource Owner는 해당 Request를 통해 인증을 진행, 인증 완료 신호로 Authorization Grant를 URL에 실어 Client에 재전송.
4. Client는 해당 권한 증서(Authorization Grant)를 Authorization Server(Facebook이나 Google의 인증 담당 서버)에 전송.
5. Authorization Server(Facebook, Google의 인증 담당 서버)는 Authorization Grant(권한 증서)를 확인한 후, User가 맞을 경우 Client(애플리케이션 서버)에게 Access Token, Refresh Token, 그리고 User의 Profile 정보(ID등등)을 발급해줌.
6. Client는 해당 Access Token을 자신의 DB에 저장하거나 Resource Owner에게 전송
7. Resource Owner(사용자)가 Resource Server(Facebook 데이터 서버)에 자원이 필요하면, Client는 Access Token을 담아 Resource Server에 요청.
8. Resource Server는 Access Token이 유효한지 확인 후, Client에게 해당 관련 자원을 전송.
9. 만일 Access Token이 만료됐거나 위조되었다면, Client(앱 서버)는 Authorization Server(Facebook의 인증담당서버)에 Refresh Token을 보내 Access Token을 재발급 
10. 그 후 다시 Resource Server에 자원 요청.
11. 만일 Refresh token도 만료되었을 경우, Resource Owner는 새로운 Authorization Grant를 Client에게 넘겨야합니다. (이는 다시 사용자가 다시 로그인 하라는 .)

## REST (Representational State Transfer), Restful API
REST는 프로토콜이나 표준이 아닌 아키텍처 원칙 세트. API 개발자는 REST를 다양한 방식으로 구현할 수 있음.

그냥 API를 구현할 때 누구나 참조 가능한 하나의 구조라고 생각하면 될 듯.

이를 기반으로 구현하면 서로 다른 사람끼리 만든 프로그램도 호환이 잘 되는 일종의 규격.


##### API가 RESTful로 간주되려면 다음 기준을 따라야 함.
1) Uniform (유니폼 인터페이스)
- Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일. 
- 한마디로 인터페이스가 통일되어있어야 함.

2) Stateless (무상태성)
- REST는 무상태성 성격을 가짐. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않음. 
- 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리. 
- 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순하다는 장점.

3) Cacheable (캐시 가능)
- REST API는 웹에서 사용하는 표준 문서 양식인 HTTP를 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용 가능. 
- 따라서 HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag 등등을 이용하면 캐싱 구현이 가능.

4) Client - Server 구조
REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.

### API의 필요성
‘애플리케이션 분리 및 통합’, ‘다양한 클라이언트의 등장’
- 최근의 서버 프로그램은 다양한 브라우저와 안드로이폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 함.
- 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.
