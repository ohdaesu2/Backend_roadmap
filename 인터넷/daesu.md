인터넷
======

### 인터넷은 어떻게  작동될까요?
- 여러 컴퓨터를 그냥 연결하기 위해서는 너무 많은 케이블이 필요하다 => 라우터(연결을 도와주는 특수 소형 컴퓨터)를 사용!
- 하지만, 컴퓨터가 너무 많아진다면 라우터 하나로는 부족하다 => 라우터끼리 연결하여 해결할 수 있다
- 너무 먼곳에 있는 곳까지도 연결을 하기 위해서는 어떻게 해야할까? => 라우터를 ISP(Internet Service Provier)에 연결한다!

IP 주소
- 네트워크에 연결된 모든 컴퓨터에는 IP 주소라는 고유의 주소가 있다.
- IP 주소는 점으로 구분 된 네 개의 숫자로 구성된 주소
- IP 주소를 기억하기 어려우니, 도메인 이름을 지정하여 기억하기 쉽게 사용한다! ex) google.com = '173.194.121.32'

---

### HTTP는 무엇일까요?
HTTP(Hyper Text Transfer Protocol)
- 인터넷에서 데이터를 주고받을 수 있는 프로토콜. 클라이언트와 웹서버의 커뮤니케이션을 도와준다.
- 클라이언트가 브라우저를 통해서 요청(request)를 하면 이에 맞는 응답(response)을 주는 형태로 동작한다.

Request HTTP 구성: method(첫 줄)/ header(두 번째 줄)/ 본문 (세 번째 줄)
~~~
GET https://velog.io/@surim014 HTTP/1.1					 // 시작줄

User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...   // 헤더
Upgrade-Insecure-Requests: 1
~~~
  1. method
  - http method: get, post, delete 등등...
  - 사이트 주소
  - HTTP version
  2. Header
  - 요청에 대한 정보
  3. 본문
  - 요청을 할 때 함께 보낼 데이터를 담는 부분

Response HTTTP 구성: 상태코드(첫 줄)/ header(두 번째 줄)/ 본문 (세 번째 줄)
~~~
HTTP/1.1 200 OK														// 시작줄
Connection: keep-alive												 // 헤더
Content-Encoding: gzip												 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...
~~~
  1. 상태코드
     - 200번대 : 성공
       - 200: 서버가 요청을 잘 처리했다.
       - 201: 작성됨. 새로운 포스팅or 댓글이 저장됐다. 
       - 202: 요청이 성공적으로 접수되었으나, 아직 해당 요청에 대해 처리 중이거나 처리 시작 전임을 의미.(실행되지 않을수도 있다.)
     - 300번대 : 추가 조치 필요 => 이동이니까 redirect 사용
       - 301: 영구 이동
       - 302: 임시 이동
     - 400번대 : 클라이언트측 오류
       - 400: 잘못된 요청 ex) django: ALLOWED_HOST
       - 401: 인증이 안돼서 권한도 없음. 
       - 403: 인증은 했지만, 팔요한 권한없음.  
       - 404: 서버에서 요청한 리소스를 찾을 수 없다. 
       - 405: 허용되지 않는 방법. POST를 지원하는 방식예서 GET을 요청하는 경우
     - 500번대 : 서버측 오류
       - 500: 서버 내부 오류 발생
       - 502: 서버가 게이트웨이나 프록시 서버 역할을 하면서 업스트림 서버로부터 유효하지 않은 응답
       - 503: 서버가 요청(request)을 처리할 준비가 되지 않은 것
     
  2. header, 본문은 request와 동일.

HTTP Version: 1.1 / 2 / 3
- HTTP 1.1: 연결당 하나의 요청에 하나의 응답으로 처리한다.
- HTTP 1.1의 단점
  1) 속도와 성능 이슈 존재
  2) HOL(Head of Line) Blocking (특정 응답 지연). 연결당 하나의 요청에 하나의 응답을 처리하기 때문에, 첫 번째 request에 대한 응답이 늦어지면 그 뒤의 request에 대한 response도 늦어지게 된다.
  3) RTT(Round Trip Time) 증가
  4) 헤더가 크다(특히, 쿠키). 헤더에는 많은 메타 정보들이 저장되어 있다. 사용자가 방문한 웹페이지는 다수의 http 요청이 발생되는데, 이 경우 매 요청시마다 중복된 헤더 값을 전송하게 되며 각 도메인에 설정된 쿠키 정보도 매 요청시마다 헤더에 포함되어 전송
  
HTTP 2 출시
- 한 커넥션에 여러개의 메세지를 동시에 주고받을 수 있다. (Multiplexed Strams)
- 요청에 커넥션 상에서 다중화 되므로 HOL Blocking 발생 제어
- 요청 리소스간 의존관계를 설정 (Stream Prioritization)
- HTML문서상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 있다. (Server Push)
- Header정보를 HPACK 압충방식을 이용하여 압축전송 (Header Compression)
---

### 브라우저와 동작 원리
브라우저: 동기적으로 HTML, CSS, JSㄹ르 해석하여 내용을 화면에 보여주는 응용 소프트웨어 ex)크롬, 사파리

브라우저 구조

![스크린샷 2022-01-03 오후 3 22 48](https://user-images.githubusercontent.com/90598930/147906877-f5994bb5-1acf-471f-862c-395a3b8533c6.png)

1. 사용자 인터페이스
   - 사용자가 접근할 수 있는 영역, URL주소 줄, 이전/다음/새로고침 버튼, 북마크 메뉴, 홈버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
2. 브라우저 엔진
   - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
3. ***렌더링 엔진***
   - 웹 서버로부터 응답 받은 자원을 웹 브라우저 상에 나타낸다. 
   - 브라우저는 서버로부터 HTML 문서를 응답받으면 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM(Document Object Model), CSSOM(CSS Object Model) 트리로 변환되고 렌더 트리로 결합한다.
   - 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 나타낸다.
4. 통신
   - HTTP 요청과 같은, 서버와 통신이 가능하게 하는 네트워크 호출에 사용
5. UI 백엔드
   - select, input 등 기본적인 위젯을 그리는 인터페이스
6. 자바스크립트 해석기
   - 자바스크립트 코드를 해석하고 실행
7. 자료 저장소
   - Cookie, LocalStorage, Indexed DB등 브라우저 메모리를 활용하여 저장하는 영역

렌더링 엔진: HTML, XML, Image 등 요청받은 내용을 브라우저 화면에 표시하는 엔진
- 렌더링 엔진은 서버로부터 응답받은 HTML 문서를 얻는 것으로 시작한다. 
- 기본 동작 과정은 다음과 같다. 
  1) 렌더링 엔진은 HTML 문서를 파싱하여 DOM 트리를 구축한다. 
  2) 그다음 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱한다. 
  3) DOM 트리와 ii.결과물을 합쳐 렌더 트리를 구축한다. 
  4) 렌더 트리 각 노드에 대해 화면 상에서 배치할 곳을 결정한다. 
  5) UI 백엔드에서 렌더 트리의 각 노드를 그린다.

자바스크립트 엔진
- HTML 파서는 script 태그를 만나면 JS를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 권한을 넘긴다.
- JS 명령을 따른 후, 다시 HTML 파서로 제어 권한을 넘겨서 중지했던 시점으로 돌아가 DOM 생성을 재개한다. 

이처럼 브라우저는 동기적으로 HTML, CSS, JS를 처리한다. 하지만 자바스크립트 엔진에 제어 권한이 있을 때, JS 코드가 완성되지 않은 DOM을 조작하게 된다면 에러가 발생한다. 
=> 이것이 JS 코드를 body 태그 하단에 위치시키는 이유이다. 

---

### DNS와 작동 원리
DNS(Domain Name System, DNS)
- 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발 
- 즉, google.com = '173.194.121.32' 이를 변환하게 해주는 시스템이다. 

![스크린샷 2022-01-03 오후 3 48 44](https://user-images.githubusercontent.com/90598930/147906899-563ea5db-1d77-47a4-809f-7f33816d9ca9.png)

DNS의 동작 원리
1. 웹 브라우저에 주소(www.naver.com)을 입력하면 LOCAL DNS에 요청하고 없다면 ROOT DNS에 요청함
2. ROOT DNS 서버로부터 "com 도메인"을 관리하는 TLD(Top-Level Domain) 이름 서버 정보 전달 받음.
3. TLD에 "www.naver.com" 요청
4. TLD에서 "naver.com" 관리하는 DNS 정보 전달 
5. "naver.com" 도메인을 관리하는 DNS 서버에 "WWW.naver.com" 호스트 네임에 대한 IP 주소 질의
6. Local DNS 서버에게 이에 맞는 IP 주소('222.122.195.6') 응답
7. Local DNS는 www.naver.com에 대한 IP 주소를 캐싱을 하고 IP 주소 정보 전달

---

### 도메인 네임은 무엇일까요?
도메인
- IP는 사람이 기억하기 어렵기 때문에, 이에 맞는 쉬운 이름을 부여한 것.
- 도메인의 구성요소는 컴퓨터의 이름과 최상위 도메인으로 구성되어 있다. 
- daum.co.kr
  - daum: 컴퓨터 이름
  - co: 국가 형태의 최상위 도메인을 의미
  - kr: 대한민국의 NIC에서 관리하는 도메인을 의미
- opentutorials.org
    - opentutorials: 컴퓨터 이름
    - org: 비영리단체의 최상위 도메인을 의미

---

### 호스팅은 무엇일까요?
호스팅
- 서버의 전체 혹은 일부를 이용할 수 있도록 임대해 주는 서비스
- 관리하기 어려운 서버를 개인이 하기 보다는 전문 업체의 호스팅 서비스를 사용하는 것이 일반적이다.

호스팅의 종류
1. 웹 호스팅
   - 하나의 서버를 여러명이 공유해서 사용. 가격이 저렴해서 대중적으로 사용
   - 하지만 트래픽 양이 증가해서 혼자 너무 많은 트래픽을 잡을 수 없도록 제약이 있다. 

2. 서버 호스팅
   - 하나의 서버를 임대. 비용이 비쌈. 
   - 서버를 단독으로 사용하므로 설치, 삭제 등의 개발이 자유롭다. 
   
3. 클라우드 호스팅
   - 서버 호스팅과 비슷하지만 물리적 서버 장비가 아닌 가상 서버를 임대
   - 자유롭게 서비스팩을 조절할 수 있고, 이용한 만큼만 금액을 지불하면 된다는 장점이 있다. 
